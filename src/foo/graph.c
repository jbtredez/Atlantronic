#include "foo/graph.h"
#include <math.h>

//! Le tableau graph_link doit être trié et il doit y avoir un liens dans chaque sens (avec la même distance)
//! Il doit être cohérent avec le tableau de noeud qui indique l'id de début des liens connectés au noeud et la taille
//! Il y a redondance des donées pour permettre un traitement plus simple et plus rapide
//! Les tableaux graph_node et graph_link sont générés automatiquement (cf graph_gen) pour eviter les erreurs

//!< noeuds du graph
const struct graph_node graph_node[GRAPH_NUM_NODE] =
{
	{{  -65536000,  -65536000},  0,  3},
	{{  -32768000,  -65536000},  3,  5},
	{{          0,  -65536000},  8,  5},
	{{   32768000,  -65536000}, 13,  5},
	{{   65536000,  -65536000}, 18,  3},
	{{  -65536000,  -32768000}, 21,  5},
	{{  -32768000,  -32768000}, 26,  8},
	{{          0,  -32768000}, 34,  8},
	{{   32768000,  -32768000}, 42,  8},
	{{   65536000,  -32768000}, 50,  5},
	{{  -65536000,          0}, 55,  5},
	{{  -32768000,          0}, 60,  8},
	{{          0,          0}, 68,  8},
	{{   32768000,          0}, 76,  8},
	{{   65536000,          0}, 84,  5},
	{{  -65536000,   32768000}, 89,  2},
	{{  -32768000,   32768000}, 91,  3},
	{{          0,   32768000}, 94,  3},
	{{   32768000,   32768000}, 97,  3},
	{{   65536000,   32768000}, 100,  2},
	{{  -65536000,   65536000}, 255,  0},
	{{  -32768000,   65536000}, 255,  0},
	{{          0,   65536000}, 255,  0},
	{{   32768000,   65536000}, 255,  0},
	{{   65536000,   65536000}, 255,  0},
};

//!< liens du graph.
const struct graph_link graph_link[GRAPH_NUM_LINK] =
{
	{ 0,  1,  500,          0u},
	{ 0,  5,  500,   16777216u},
	{ 0,  6,  707,    8388644u},
	{ 1,  0,  500,   33554432u},
	{ 1,  2,  500,          0u},
	{ 1,  5,  707,   25165787u},
	{ 1,  6,  500,   16777216u},
	{ 1,  7,  707,    8388644u},
	{ 2,  1,  500,   33554432u},
	{ 2,  3,  500,          0u},
	{ 2,  6,  707,   25165787u},
	{ 2,  7,  500,   16777216u},
	{ 2,  8,  707,    8388644u},
	{ 3,  2,  500,   33554432u},
	{ 3,  4,  500,          0u},
	{ 3,  7,  707,   25165787u},
	{ 3,  8,  500,   16777216u},
	{ 3,  9,  707,    8388644u},
	{ 4,  3,  500,   33554432u},
	{ 4,  8,  707,   25165787u},
	{ 4,  9,  500,   16777216u},
	{ 5,  0,  500, 4278190080u},
	{ 5,  1,  707, 4286578651u},
	{ 5,  6,  500,          0u},
	{ 5, 10,  500,   16777216u},
	{ 5, 11,  707,    8388644u},
	{ 6,  0,  707, 4269801508u},
	{ 6,  1,  500, 4278190080u},
	{ 6,  2,  707, 4286578651u},
	{ 6,  5,  500,   33554432u},
	{ 6,  7,  500,          0u},
	{ 6, 10,  707,   25165787u},
	{ 6, 11,  500,   16777216u},
	{ 6, 12,  707,    8388644u},
	{ 7,  1,  707, 4269801508u},
	{ 7,  2,  500, 4278190080u},
	{ 7,  3,  707, 4286578651u},
	{ 7,  6,  500,   33554432u},
	{ 7,  8,  500,          0u},
	{ 7, 11,  707,   25165787u},
	{ 7, 12,  500,   16777216u},
	{ 7, 13,  707,    8388644u},
	{ 8,  2,  707, 4269801508u},
	{ 8,  3,  500, 4278190080u},
	{ 8,  4,  707, 4286578651u},
	{ 8,  7,  500,   33554432u},
	{ 8,  9,  500,          0u},
	{ 8, 12,  707,   25165787u},
	{ 8, 13,  500,   16777216u},
	{ 8, 14,  707,    8388644u},
	{ 9,  3,  707, 4269801508u},
	{ 9,  4,  500, 4278190080u},
	{ 9,  8,  500,   33554432u},
	{ 9, 13,  707,   25165787u},
	{ 9, 14,  500,   16777216u},
	{10,  5,  500, 4278190080u},
	{10,  6,  707, 4286578651u},
	{10, 11,  500,          0u},
	{10, 15,  500,   16777216u},
	{10, 16,  707,    8388644u},
	{11,  5,  707, 4269801508u},
	{11,  6,  500, 4278190080u},
	{11,  7,  707, 4286578651u},
	{11, 10,  500,   33554432u},
	{11, 12,  500,          0u},
	{11, 15,  707,   25165787u},
	{11, 16,  500,   16777216u},
	{11, 17,  707,    8388644u},
	{12,  6,  707, 4269801508u},
	{12,  7,  500, 4278190080u},
	{12,  8,  707, 4286578651u},
	{12, 11,  500,   33554432u},
	{12, 13,  500,          0u},
	{12, 16,  707,   25165787u},
	{12, 17,  500,   16777216u},
	{12, 18,  707,    8388644u},
	{13,  7,  707, 4269801508u},
	{13,  8,  500, 4278190080u},
	{13,  9,  707, 4286578651u},
	{13, 12,  500,   33554432u},
	{13, 14,  500,          0u},
	{13, 17,  707,   25165787u},
	{13, 18,  500,   16777216u},
	{13, 19,  707,    8388644u},
	{14,  8,  707, 4269801508u},
	{14,  9,  500, 4278190080u},
	{14, 13,  500,   33554432u},
	{14, 18,  707,   25165787u},
	{14, 19,  500,   16777216u},
	{15, 10,  500, 4278190080u},
	{15, 11,  707, 4286578651u},
	{15, 16,  500,          0u},
	{15, 20,  500,   16777216u},
	{15, 21,  707,    8388644u},
	{16, 10,  707, 4269801508u},
	{16, 11,  500, 4278190080u},
	{16, 12,  707, 4286578651u},
	{16, 15,  500,   33554432u},
	{16, 17,  500,          0u},
	{16, 20,  707,   25165787u},
	{16, 21,  500,   16777216u},
	{16, 22,  707,    8388644u},
	{17, 11,  707, 4269801508u},
	{17, 12,  500, 4278190080u},
	{17, 13,  707, 4286578651u},
	{17, 16,  500,   33554432u},
	{17, 18,  500,          0u},
	{17, 21,  707,   25165787u},
	{17, 22,  500,   16777216u},
	{17, 23,  707,    8388644u},
	{18, 12,  707, 4269801508u},
	{18, 13,  500, 4278190080u},
	{18, 14,  707, 4286578651u},
	{18, 17,  500,   33554432u},
	{18, 19,  500,          0u},
	{18, 22,  707,   25165787u},
	{18, 23,  500,   16777216u},
	{18, 24,  707,    8388644u},
	{19, 13,  707, 4269801508u},
	{19, 14,  500, 4278190080u},
	{19, 18,  500,   33554432u},
	{19, 23,  707,   25165787u},
	{19, 24,  500,   16777216u},
	{20, 15,  500, 4278190080u},
	{20, 16,  707, 4286578651u},
	{20, 21,  500,          0u},
	{21, 15,  707, 4269801508u},
	{21, 16,  500, 4278190080u},
	{21, 17,  707, 4286578651u},
	{21, 20,  500,   33554432u},
	{21, 22,  500,          0u},
	{22, 16,  707, 4269801508u},
	{22, 17,  500, 4278190080u},
	{22, 18,  707, 4286578651u},
	{22, 21,  500,   33554432u},
	{22, 23,  500,          0u},
	{23, 17,  707, 4269801508u},
	{23, 18,  500, 4278190080u},
	{23, 19,  707, 4286578651u},
	{23, 22,  500,   33554432u},
	{23, 24,  500,          0u},
	{24, 18,  707, 4269801508u},
	{24, 19,  500, 4278190080u},
	{24, 23,  500,   33554432u},
};

int graph_dijkstra(int a, int b, struct graph_dijkstra_info* info, uint8_t* valid_links)
{
	int i;
	int j;

	// init
	for( i=0 ; i < GRAPH_NUM_NODE; i++)
	{
		info[i].dist = 0xFFFF;
		info[i].prev_node = a;
		info[i].is_best = 0;
	}

	// a est a une distance de 0 de lui même et il n'y a pas mieux
	info[a].dist = 0;
	i = a;

	while( i != b)
	{
		info[i].is_best = 1;

		int max = graph_node[i].link_id + graph_node[i].link_num;
		for(j = graph_node[i].link_id; j < max; j++)
		{
			if( valid_links[j])
			{
				int connected_node = graph_link[j].b;
				// calcul de la distance en passant par la
				uint16_t dist = info[i].dist + graph_link[j].dist;
				if( info[connected_node].dist > dist)
				{
					// on a trouvé un chemin plus court pour aller vers "connected_node"
					info[connected_node].dist = dist;
					info[connected_node].prev_node = i;
				}
			}
		}

		uint16_t best_dist = 0xFFFF;
		i = a;
		for(j = 0; j<GRAPH_NUM_NODE; j++)
		{
			if( ! info[j].is_best && info[j].dist < best_dist)
			{
				best_dist = info[j].dist;
				i = j;
			}
		}
		if(i == a)
		{
			// rien de trouvé
			return -1;
		}
	}

	info[i].is_best = 1;

	return 0;
}

int graph_compute_node_distance(struct fx_vect2 pos, struct graph_node_dist* node_dist )
{
	int i;
	int j;
	int64_t dx;
	int64_t dy;
	uint16_t dist;

	for(i = 0; i< GRAPH_NUM_NODE; i++)
	{
		dx = pos.x - graph_node[i].pos.x;
		dy = pos.y - graph_node[i].pos.y;
		dist = ((int32_t)sqrtf(dx * dx + dy * dy)) >> 16;

		j = i-1;
		while(j >= 0 && node_dist[j].dist > dist)
		{
			node_dist[j+1] = node_dist[j];
			j--;
		}
		node_dist[j+1].dist = dist;
		node_dist[j+1].id = i;
	}

	return 0;
}
